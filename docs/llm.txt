# tsdav Documentation

This file contains the complete API documentation for tsdav, a TypeScript WebDAV client library for CalDAV and CardDAV.

## Table of Contents

1. Introduction
2. WebDAV Core Functions
3. Account Management
4. Collection Operations
5. CalDAV Operations
6. CardDAV Operations
7. Type Definitions
8. Helper Functions
9. Cloud Providers
10. Smart Calendar Sync
11. Contributing

---

## 1. Introduction

### What is WebDAV?

[WEBDAV](https://tools.ietf.org/html/rfc4918), `Web Distributed Authoring and Versioning`, is an extension of HTTP to allow handling distributed authoring and versioning of various resources.

It's very common to be used for cloud storage (limited support), as well as calendar and contacts information syncing.

### Cloud Provider Support Status

| Provider name | WEBDAV | CALDAV | CARDDAV |
| ------------- | ------ | ------ | ------- |
| Apple    | ✅     | ✅     | ✅      |
| Google  | ✅     | ✅     | ✅      |
| Fastmail      | ✅     | ✅     | ✅      |
| Nextcloud     | ✅     | ✅     | ✅      |
| Baikal        | ✅     | ✅     | ✅      |
| ZOHO          | ✅     | ✅     | ⛔️     |
| DAViCal       | ✅     | ✅     | ⛔️     |
| Forward Email | ⛔️ | ✅ | ✅ |

### Installation

```bash
yarn add tsdav
```

or

```bash
npm install tsdav
```

### Basic Usage

#### Import the dependency

```ts
import { createDAVClient } from 'tsdav';
```

or

```ts
import tsdav from 'tsdav';
```

#### Create Client

By creating a client, you can now use all tsdav methods without supplying authentication header or accounts. However, you can always pass in custom header or account to override the default for each request.

**For Google:**

```ts
const client = await createDAVClient({
  serverUrl: 'https://apidata.googleusercontent.com/caldav/v2/',
  credentials: {
    tokenUrl: 'https://accounts.google.com/o/oauth2/token',
    username: 'YOUR_EMAIL_ADDRESS',
    refreshToken: 'YOUR_REFRESH_TOKEN_WITH_CALDAV_PERMISSION',
    clientId: 'YOUR_CLIENT_ID',
    clientSecret: 'YOUR_CLIENT_SECRET',
  },
  authMethod: 'Oauth',
  defaultAccountType: 'caldav',
});
```

**For Apple:**

```ts
const client = await createDAVClient({
  serverUrl: 'https://caldav.icloud.com',
  credentials: {
    username: 'YOUR_APPLE_ID',
    password: 'YOUR_APP_SPECIFIC_PASSWORD',
  },
  authMethod: 'Basic',
  defaultAccountType: 'caldav',
});
```

**Class-based API (v1.1.0+):**

You need to call `client.login()` with this method before using the functions.

```ts
const client = new DAVClient({
  serverUrl: 'https://caldav.icloud.com',
  credentials: {
    username: 'YOUR_APPLE_ID',
    password: 'YOUR_APP_SPECIFIC_PASSWORD',
  },
  authMethod: 'Basic',
  defaultAccountType: 'caldav',
});

await client.login();
```

---

## 2. WebDAV Core Functions

### `davRequest`

Core request function of the library, based on `cross-fetch`, so the API should work across browser and Node.js. Uses `xml-js` so that JS objects can be passed as request.

```ts
const [result] = await davRequest({
  url: 'https://caldav.icloud.com/',
  init: {
    method: 'PROPFIND',
    namespace: 'd',
    body: {
      propfind: {
        _attributes: {
          'xmlns:d': 'DAV:',
        },
        prop: { 'd:current-user-principal': {} },
      },
    },
    headers: {
      authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
    },
  },
});
```

**Arguments:**
- `url` **required**, request url
- `init` **required**, [DAVRequest](#davrequest) Object
- `convertIncoming` defaults to `true`, whether to convert the passed in init object request body. If `false`, davRequest would expect `init->body` is `xml` string, and would send it directly to target `url` without processing.
- `parseOutgoing` defaults to `true`, whether to parse the return value in response body. If `false`, the response `raw` would be raw `xml` string returned from server.
- `fetchOptions` options to pass to underlying fetch function

**Return Value:**
Array of [DAVResponse](#davresponse). Response->raw will be `string` if `parseOutgoing` is `false` or request failed.

**Behavior:**
Depending on options, uses `xml-js` to convert passed in JSON object into valid XML request, also uses `xml-js` to convert received XML response into JSON object. If request failed, response->raw will be raw response text returned from server.

### `propfind`

The [PROPFIND](https://datatracker.ietf.org/doc/html/rfc4918#section-9.1) method retrieves properties defined on the resource identified by the Request-URI.

```ts
const [result] = await propfind({
  url: 'https://caldav.icloud.com/',
  props: [{ name: 'current-user-principal', namespace: DAVNamespace.DAV }],
  headers: {
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `url` **required**, request url
- `props` **required**, [ElementCompact](#elementcompact) props to find
- `depth` [DAVDepth](#davdepth)
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function

**Return Value:**
Array of [DAVResponse](#davresponse)

### `createObject`

Create an object.

```ts
const response = await createObject({
  url: 'https://caldav.icloud.com/123456/calendars/A5639426-B73B-4F90-86AB-D70F7F603E75/test.ics',
  data: 'BEGIN:VCALENDAR\nVERSION:2.0\n...',
  headers: {
    'content-type': 'text/calendar; charset=utf-8',
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `url` **required**, object url
- `data` **required**, object data
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function

**Return Value:**
[fetch api response](https://developer.mozilla.org/en-US/docs/Web/API/Response)

**Behavior:**
Sends PUT request to target url with body of data, with `If-None-Match` header `*` to avoid accidental overwrite.

### `updateObject`

Update an object.

```ts
const response = await updateObject({
  url: 'https://caldav.icloud.com/123456/calendars/A5639426-B73B-4F90-86AB-D70F7F603E75/test.ics',
  data: 'BEGIN:VCALENDAR\nVERSION:2.0\n...',
  etag: '"63758758580"',
  headers: {
    'content-type': 'text/calendar; charset=utf-8',
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `url` **required**, url of object to update
- `data` **required**, new object content
- `etag` the version string of content. If [etag](https://tools.ietf.org/id/draft-reschke-http-etag-on-write-08.html) changed, `data` must have been changed.
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function

**Return Value:**
[fetch api response](https://developer.mozilla.org/en-US/docs/Web/API/Response)

**Behavior:**
Sends PUT request with data body and etag header. Object will not be updated if etag does not match.

### `deleteObject`

Delete an object.

```ts
const response = await deleteObject({
  url: 'https://caldav.icloud.com/123456/calendars/A5639426-B73B-4F90-86AB-D70F7F603E75/test.ics',
  etag: '"63758758580"',
  headers: {
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `url` **required**, url of object to delete
- `etag` the version string of content. If [etag](https://tools.ietf.org/id/draft-reschke-http-etag-on-write-08.html) changed, `data` must have been changed.
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function

**Return Value:**
[fetch api response](https://developer.mozilla.org/en-US/docs/Web/API/Response)

**Behavior:**
Sends DELETE request with etag header. Object will not be deleted if etag does not match.

---

## 3. Account Management

### `createAccount`

Construct WebDAV account information needed for requests.

```ts
const account = await createAccount({
  account: {
    serverUrl: 'https://caldav.icloud.com/',
    accountType: 'caldav',
  },
  headers: {
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `account` **required**, account with `serverUrl` and `accountType`
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function
- `loadCollections` defaults to false, whether to load all collections of the account
- `loadObjects` defaults to false, whether to load all objects of collections as well, must be used with `loadCollections` set to `true`

**Return Value:**
Created [DAVAccount](#davaccount)

**Behavior:**
Performs serviceDiscovery, fetchHomeUrl, fetchPrincipalUrl for account information gathering. Makes fetch collections & fetch objects requests depending on options.

### `serviceDiscovery`

Automatically discover service root url.

```ts
const url = await serviceDiscovery({
  account: { serverUrl: 'https://caldav.icloud.com/', accountType: 'caldav' },
  headers: {
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `account` **required**, account with `serverUrl` and `accountType`
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function

**Return Value:**
Root url

**Behavior:**
Uses `/.well-known/` request to follow redirects to find redirected url.

### `fetchPrincipalUrl`

Fetch the principal URL for the account.

### `fetchHomeUrl`

Fetch the home set URL for the account.

---

## 4. Collection Operations

### `collectionQuery`

Query collection properties.

### `syncCollection`

Sync collection using sync-token.

### `smartCollectionSync`

Smart version of collection sync that combines ctag based sync with WebDAV sync.

```ts
const { created, updated, deleted } = (
  await smartCollectionSync({
    collection: {
      url: 'https://caldav.icloud.com/12345676/calendars/c623f6be-a2d4-4c60-932a-043e67025dde/',
      ctag: 'eWd9Vz8OwS0DE==',
      syncToken: 'eWdLSfo8439Vz8OwS0DE==',
      objects: [...],
      objectMultiGet: calendarMultiGet,
    },
    method: 'webdav',
    detailedResult: true,
    account: {
      accountType: 'caldav',
      homeUrl: 'https://caldav.icloud.com/123456/calendars/',
    },
    headers: {
      authorization: 'Basic x0C9ueWd9Vz8OwS0DEAtkAlj',
    },
  })
).objects;
```

**Arguments:**
- `collection` **required**, the target collection to sync
- `method` defaults to auto detect, one of `basic` and `webdav`
- `account` [DAVAccount](#davaccount) to sync
- `detailedResult` boolean indicate whether the return value should be detailed or not
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function

**Return Value:**
Depends on `detailedResult` option.

If `detailedResult` is falsy: array of latest [DAVObject](#davobject)

If `detailedResult` is `true`: an object with:
- `objects`
  - `created` array of [DAVObject](#davobject)
  - `updated` array of [DAVObject](#davobject)
  - `deleted` array of [DAVObject](#davobject)

**Behavior:**
Detects if collection supports sync-collection REPORT. If they support it, uses [rfc6578 webdav sync](https://datatracker.ietf.org/doc/html/rfc6578) to detect if collection changed, else uses ctag to detect if collection changed. If collection changed, fetches the latest list of [DAVObject](#davobject) from remote, compares the provided list and the latest list to find out `created`, `updated`, and `deleted` objects.

### `isCollectionDirty`

Check if collection has changes.

### `makeCollection`

Create a new collection.

### `supportedReportSet`

Get supported report types.

---

## 5. CalDAV Operations

### `fetchCalendars`

Get all calendars of the passed in CalDAV account.

```ts
const calendars = await fetchCalendars({
  account,
  headers: {
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `account` [DAVAccount](#davaccount)
- `header` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function
- `props` [CALDAV prop element](https://datatracker.ietf.org/doc/html/rfc4791#section-9.6.4) in [ElementCompact](#elementcompact) form, overriding default props to fetch
- `projectedProps` custom props projection object, used as a map to map fetched custom props to values

:::caution
When overriding props, supported-calendar-component-set and resourcetype are required
:::

**Return Value:**
Array of [DAVCalendar](#davcalendar) of the account

**Behavior:**
Uses `PROPFIND` to get all the basic info about calendars on certain account.

### `fetchCalendarObjects`

Get calendar objects (events/todos) from a calendar.

### `calendarMultiGet`

Batch fetch calendar objects by URLs.

### `calendarQuery`

Query calendar objects with filters.

### `createCalendarObject`

Create new calendar object.

### `updateCalendarObject`

Update existing calendar object.

### `deleteCalendarObject`

Delete calendar object.

### `syncCalendars`

Sync multiple calendars.

```ts
const { created, updated, deleted } = await client.syncCalendars({
  calendars: myCalendars,
  detailedResult: true,
});
```

### `makeCalendar`

Create new calendar.

### `fetchCalendarUserAddresses`

Get calendar user addresses.

### `freeBusyQuery`

Query free/busy information.

---

## 6. CardDAV Operations

### `fetchAddressBooks`

Get all address books of the passed in CardDAV account.

```ts
const addressBooks = await fetchAddressBooks({
  account,
  headers: {
    authorization: 'Basic x0C9uFWd9Vz8OwS0DEAtkAlj',
  },
});
```

**Arguments:**
- `account` [DAVAccount](#davaccount)
- `props` [CARDDAV prop element](https://datatracker.ietf.org/doc/html/rfc6352#section-10.4.2) in [ElementCompact](#elementcompact) form, overriding default props to fetch.
- `headers` request headers
- `headersToExclude` array of keys of the headers you want to exclude
- `fetchOptions` options to pass to underlying fetch function

:::caution
When overriding props, resourcetype is required
:::

**Return Value:**
Array of [DAVAddressBook](#davaddressbook)

**Behavior:**
Uses `PROPFIND` to get all the basic info about address book on certain account.

### `fetchVCards`

Get vCard objects from an address book.

### `addressBookMultiGet`

Batch fetch vCards by URLs.

### `addressBookQuery`

Query vCards with filters.

### `createVCard`

Create new vCard.

### `updateVCard`

Update existing vCard.

### `deleteVCard`

Delete vCard.

---

## 7. Type Definitions

### `DAVAccount`

```ts
export type DAVAccount = {
  accountType: 'caldav' | 'carddav';
  serverUrl: string;
  credentials?: DAVCredentials;
  rootUrl?: string;
  principalUrl?: string;
  homeUrl?: string;
  calendars?: DAVCalendar[];
  addressBooks?: DAVAddressBook[];
};
```

- `accountType` can be `caldav` or `carddav`
- `serverUrl` server url of the account
- `credentials` [DAVCredentials](#davcredentials)
- `rootUrl` root url of the account
- `principalUrl` principal resource url
- `homeUrl` resource home set url
- `calendars` calendars of the account, will only be populated by createAccount
- `addressBooks` address books of the account, will only be populated by createAccount

### `DAVCalendar`

```ts
export type DAVCalendar = {
  components?: string[];
  timezone?: string;
  projectedProps?: Record<string, unknown>;
} & DAVCollection;
```

Alias of [DAVCollection](#davcollection) with:
- `timezone` iana timezone name of calendar
- `components` array of calendar components defined in [rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.6)
- `projectedProps` object of fetched additional props by passing custom props to fetchCalendars function

### `DAVCollection`

Base type for collections (calendars, address books).

### `DAVCalendarObject`

Represents a calendar event or todo object.

### `DAVAddressBook`

Represents an address book collection.

### `DAVVCard`

Represents a vCard contact object.

### `DAVObject`

Base type for WebDAV objects.

### `DAVCredentials`

Authentication credentials (Basic or OAuth).

### `DAVRequest`

Request configuration object.

### `DAVResponse`

Response object with parsed XML.

### `DAVDepth`

Depth header for PROPFIND requests.

### `DAVTokens`

OAuth tokens structure.

### `ElementCompact`

XML element representation as JS object for use with xml-js.

---

## 8. Helper Functions

### Auth Helpers

#### `getBasicAuthHeaders`

Convert the `username:password` into base64 auth header string:

```ts
const result = getBasicAuthHeaders({
  username: 'test',
  password: '12345',
});
```

**Return Value:**
```ts
{
  authorization: 'Basic dGVzdDoxMjM0NQ==';
}
```

#### `fetchOauthTokens`

Fetch OAuth token using code obtained from OAuth2 authorization code grant.

```ts
const tokens = await fetchOauthTokens({
  authorizationCode: '123',
  clientId: 'clientId',
  clientSecret: 'clientSecret',
  tokenUrl: 'https://oauth.example.com/tokens',
  redirectUrl: 'https://yourdomain.com/oauth-callback',
});
```

#### `refreshAccessToken`

Using refresh token to fetch access token from given token endpoint.

```ts
const result = await refreshAccessToken({
  clientId: 'clientId',
  clientSecret: 'clientSecret',
  tokenUrl: 'https://oauth.example.com/tokens',
  refreshToken: 'iHwWwqytfW3AfOjNbM1HLg',
});
```

#### `getOauthHeaders`

The combination of `fetchOauthTokens` and `refreshAccessToken`, it will return the authorization header needed for authorizing the requests as well as automatically renewing the access token using refresh token obtained from server when it expires.

### Request Helpers

#### `urlEquals`

Check if two URLs are mostly equal. Will first trim out white spaces, and can omit the last `/`.

#### `urlContains`

Basically `urlEqual`, but without length constraint.

#### `getDAVAttribute`

Convert `DAVNamespace` to intended format to be consumed by `xml-js` to be used as `xml` attributes.

#### `cleanupFalsy`

Clean up `falsy` values within an object, useful when sending headers where undefined object property will cause an error.

### Constants

- `DAVNamespace` - WebDAV namespace constants
- `DAVAttributeMap` - Attribute mapping
- `DAVNamespaceShort` - Short namespace aliases

---

## 9. Cloud Providers

### Prepare Credentials

#### Apple

For Apple you want to go to [this page](https://support.apple.com/en-us/HT204397) and after following the guide, you will have Apple ID and app-specific password.

#### Google

For Google you want to go to Google Cloud Platform/Credentials page, then create a credential that suits your use case. You want `clientId`, `clientSecret` and after this. Also you need to enable Google CalDAV/CardDAV for your project.

Also you need to setup OAuth screen, add needed OAuth2 scopes (`https://www.googleapis.com/auth/calendar` for CalDAV), use proper OAuth2 grant flow and you might need to get your application verified by Google in order to be able to use CalDAV/CardDAV API. Refer to [this page](https://developers.google.com/identity/protocols/oauth2) for more details.

After the OAuth2 offline grant you should be able to obtain OAuth2 refresh token.

#### Fastmail

Generate an app specific password just like Apple, follow [this guide](https://www.fastmail.help/hc/en-us/articles/360058752834) for more information.

#### ZOHO

Please follow [official guide](https://help.zoho.com/portal/en/kb/calendar/syncing-other-calendars/articles/setting-up-caldav-sync-in-zoho-calendar#Configuring_CalDAV_sync_between_Zoho_Calendar_and_your_device)

#### Forward Email

Please follow [official guide](https://forwardemail.net/en/faq#do-you-support-calendars-caldav)

### Caveats

Some cloud providers' APIs are not very standard, they might include several quirks.

#### Google

1. CalDAV will always use UID inside `ics` file as filename, for example if you created a new event with name `1.ics` but have `abc` as its UID inside, you can only access it using `abc.ics`.
2. CardDAV will always generate a new UID for your `.vcf` files. For example a file created with name `1.vcf` with UID `abc`, it will have a UID like `1bcde2e` inside the actual created data.
3. Both CalDAV and CardDAV will add custom data entries inside your `ics` and `vcf` files like new `PRODID`, new `TIMETAMP` and some custom `X-` fields.
4. For CardDAV, you cannot create a `vcf` file with the same name again even if it's already deleted.

#### ZOHO

1. CalDAV will always use UID inside `ics` file as filename, for example if you created a new event with name `1.ics` but have `abc` as its UID inside, you can only access it using `abc.ics`.
2. Both CalDAV and CardDAV will add custom data entries inside your `ics` and `vcf` files like new `PRODID`, new `TIMETAMP` and some custom `X-` fields.
3. For CalDAV, you cannot create a `ics` file with the same UUID again even if it's already deleted.

#### NextCloud

1. Object deletion will result in original object be renamed rather than actual deletion. This can cause problems at times.

---

## 10. Smart Calendar Sync

To actually achieve two-way syncing of calendar events between cloud provider and your service.

### Preparation

You need to create database structures to store the calendar info.

#### App Calendar

Your app's calendar object type like:

```ts
type AppCalendar = {
    id: string;
    userId: string;
    timezone?: string;
    name?: string;
    description?: string;
    email?: string;
    createdAt: string;
    updatedAt: string;
}
```

This table is used for your app's display, daily use, etc. Optional if you do not already have a table like this or you do not want one-to-many relations with your app calendar.

#### CalDAV Calendar

You need to store CalDAV calendar information obtained from `fetchCalendars`:

```typescript
type CaldavCalendar = {
  id: string;
  userId: string;
  timezone: string;
  name: string;
  source: string; // your caldav provider name
  ctag: string; // obtained from remote
  syncToken: string; // obtained from remote
  url: string;
  credentialId: string;
  createAt: string;
};
```

#### Credentials

Save CalDAV calendar credentials in another table, encryption is recommended:

```ts
type CalendarCredential = {
  account: string;
  refreshToken?: string;
  password?: string;
  valid: boolean;
  source: string; // your caldav provider name
}
```

#### CalDAV Calendar Objects

You also need to store CalDAV calendar objects obtained from `fetchCalendarObjects`:

```ts
export type CalendarObject = {
  id: string;
  calendarId: string; // foreign key reference the CaldavCalendar if needed
  url: string;
  etag: string;
  start: string; // recommend to have this field for easy filtering/sorting
  end: string; // recommend to have this field for easy filtering/sorting
  data: string; // actual ics data
};
```

To parse and obtain information from ics data, it's recommended to use a combination of:
- https://github.com/natelindev/pretty-jcal
- https://github.com/kewisch/ical.js

For generating new ics data, it's recommended to use:
- https://github.com/nwcell/ics.js/

### Actual Syncing

First you need to have user go through authorization process and obtain valid `CalendarCredential`, the method differs for each CalDAV provider.

After having obtained the credentials, you can begin the actual sync.

#### Remote to Local

You can use `syncCalendars` function from the lib with `detailedResult` set as `true`:

```ts
const { created, updated, deleted } = await client.syncCalendars({
  oldCalendars: localCalendars.map((lc) => ({
      displayName: lc.name,
      syncToken: lc.syncToken,
      ctag: lc.ctag,
      url: lc.url,
    })
  ),
  detailedResult: true,
});
```

Make sure you send the `syncToken` and `ctag`, this way the remote will know your last sync and identify the calendar changes.

For calendar object changes, use `smartCollectionSync`:

```ts
const {
  created: createdObjects,
  updated: updatedObjects,
  deleted: deletedObjects,
} = (
  await client.smartCollectionSync({
    collection: {
      url: lc.url,
      ctag: lc.ctag,
      syncToken: lc.syncToken,
      objects: localObjects,
      objectMultiGet: client.calendarMultiGet,
    },
    method: 'webdav',
    detailedResult: true,
  })
).objects;
```

Always normalize calendar object URLs using `URL.resolve` when combining parent collection URLs with relative paths.

#### Local to Remote

When going local to remote, it's rather easy. Just generate the ics data and then use `createCalendarObject`, `updateCalendarObject` and `deleteCalendarObject` directly on remote CalDAV calendars. Update your locally stored calendar objects in your database after remote operation success.

---

## 11. Contributing

### Build

```bash
npm run build
```

or

```bash
yarn build
```

### Test

To run tests locally, you need to setup environment variables using `.env` file from `.env.example`:

```bash
mv .env.example .env
```

and fill in the missing values.

If you didn't add any new API, you should set `MOCK_FETCH="true"`.
If you added new API and need to test against cloud providers, you should set `MOCK_FETCH="false"` and `RECORD_NETWORK_REQUESTS="true"` to update network request mock data.

### WebDAV Quick Guide

WebDAV uses XML for all its data when communicating. The basic element is `object`, multiple `object`s can form a `collection`. WebDAV servers have `account`s and an `account` has a `principal` resource (i.e. the default, main resource) and under that principal resource we have `home set` of the said resource where your actual resources are.

`syncToken` and `ctag` are basically like hash of the object/collection. If anything in it changes, this token will change.

For CalDAV, the calendar data in CalDAV are in `rfc5545` ical format. There's `iCal2Js` and `js2iCal` function with [pretty-jcal](https://github.com/natelindev/pretty-jcal) to help you convert them from/to JS objects.

### WebDAV Operations vs REST

| Operation | WebDAV | REST |
|-----------|--------|------|
| Create collection | `MKCOL /entities/$predefined_id` (Status: 201 Created) | `POST /entities` with JSON body (Status: 200 with new id) |
| Create entity | `PUT /entities/$predefined_id` with body (Status: 201 Created) | `POST /entities`, receive id as part of Content-Location header |
| Update entity body | `PUT /entities/$predefined_id` with new body (Status: 204 No Content) | `PUT /entities/$id` with full JSON body (Status: 200) or `PATCH /entities/$id` with partial JSON (Status: 200) |
| Update entity attributes | `PROPPATCH /entities/$id` with XML body (Status: 207) | Same as update entity body |
| Delete entity | `DELETE /entities/$id` (Status: 204 no content) | `DELETE /entities/$id` (Status: 204 no content) |
| List entities | `PROPFIND /entities` with XML body (Status: 207 multi-status XML) | `GET /entities` (Status: 200 OK, JSON array) |
| Get entity | `GET /entities/$id` (Status: 200 OK with entity body) | `GET /entities/$id` (Status: 200 OK, JSON body) |
| Get entity attributes | `PROPFIND /entities/$id` with XML body (Status: 207 multi-status XML) | Same as get entity |

---

## Helper: XML to JS Converter

Helper to convert XML to expected JS object to be consumed by tsdav.

The library uses `xml-js` to convert between XML and JavaScript objects. XML elements are represented as objects with `_attributes` for attributes and child elements as properties.

Example XML:
```xml
<?xml version="1.0" encoding="utf-8" ?>
<C:calendar-query xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:caldav">
  <D:prop>
    <C:calendar-data>
      <C:expand start="20060103T000000Z" end="20060105T000000Z"/>
    </C:calendar-data>
  </D:prop>
  <C:filter>
    <C:comp-filter name="VCALENDAR">
      <C:comp-filter name="VEVENT">
        <C:time-range start="20060103T000000Z" end="20060105T000000Z"/>
      </C:comp-filter>
    </C:comp-filter>
  </C:filter>
</C:calendar-query>
```

Equivalent JS object:
```ts
{
  calendarQuery: {
    _attributes: {
      'xmlns:D': 'DAV:',
      'xmlns:C': 'urn:ietf:params:xml:ns:caldav',
    },
    prop: {
      calendarData: {
        expand: {
          _attributes: {
            start: '20060103T000000Z',
            end: '20060105T000000Z',
          },
        },
      },
    },
    filter: {
      compFilter: {
        _attributes: {
          name: 'VCALENDAR',
        },
        compFilter: {
          _attributes: {
            name: 'VEVENT',
          },
          timeRange: {
            _attributes: {
              start: '20060103T000000Z',
              end: '20060105T000000Z',
            },
          },
        },
      },
    },
  },
}
```

---

## Migration Guide

### 1.1.x -> 2.x.x

Auto prop/filter converter that can help you transition from 1.1.x to 2.x.x.

Props format changed from array of objects with `name` and `namespace` to ElementCompact format.

Filters format changed from array of filter objects to ElementCompact format.

---

## Important Notes

- Always normalize calendar object URLs using `URL.resolve` when combining parent collection URLs with relative paths
- When overriding CalDAV/CardDAV `props`, keep required fields (`supported-calendar-component-set`, `resourcetype`) to prevent server errors
- Some providers have quirks (Google renames objects to UID-based filenames, Zoho prevents duplicate UIDs, Nextcloud renames on delete)
- Integration tests hit live services - guard credentials via environment variables
- Use `DEBUG=tsdav:*` environment variable to enable debug logs for HTTP traffic
